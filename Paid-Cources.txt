
#Testing Approaches, Terms, and Considerations

When it comes to testing in software development, several approaches, terms, and considerations come into play, depending on the type of application you're building (e.g., web, API, mobile). Below is a breakdown to help you understand key concepts, testing methodologies, and things to keep in mind when creating a testing strategy for your application.

1. Testing Approaches
These are different levels of testing that help ensure the software is functioning as expected.

a) Unit Testing
Definition: Unit testing involves testing individual units of code (such as a single function or method) in isolation.
Goal: To verify that each part of the code works as expected.
Tools: PHPUnit (for PHP), Jest (for JavaScript), JUnit (for Java).
Example: Testing a function that calculates the sum of two numbers.
b) Integration Testing
Definition: Integration tests check if multiple modules or components of the system work together as expected.
Goal: To ensure that the system components interact correctly.
Tools: PHPUnit (for PHP), Mocha (for JavaScript).
Example: Testing a function that interacts with the database or an external API.
c) Functional Testing
Definition: Functional tests focus on verifying the functionality of the system as a whole, often in terms of user stories or business requirements.
Goal: To ensure the system behaves according to specified requirements.
Tools: Selenium, Cypress, Laravel Dusk.
Example: Testing the login process of a website.
d) End-to-End (E2E) Testing
Definition: E2E testing simulates a user journey from start to finish to ensure the application works as intended when all parts are integrated.
Goal: To test the complete flow of the application, from front-end to back-end.
Tools: Cypress, Selenium, TestCafe.
Example: Testing the entire e-commerce checkout process.
e) Acceptance Testing
Definition: Acceptance tests ensure the software meets the business requirements and is ready for release.
Goal: To validate the software against business or functional requirements.
Tools: Cucumber, Behat.
Example: Testing if a feature like password reset works as expected by the product owner’s specifications.
f) Performance Testing
Definition: Performance testing is focused on determining how the system performs under load, including how it handles high traffic or large amounts of data.
Types:
Load Testing: To check how the system handles expected load.
Stress Testing: To check how the system behaves under extreme conditions (overload).
Scalability Testing: To see how the system scales as demand increases.
Tools: Apache JMeter, LoadRunner.
Example: Testing how a website performs when 10,000 users are trying to access it simultaneously.
g) Security Testing
Definition: Security testing ensures the system is protected against unauthorized access, data breaches, and other vulnerabilities.
Goal: To verify that the software is secure from common threats like SQL injection, XSS, and other vulnerabilities.
Tools: OWASP ZAP, Burp Suite.
Example: Testing if an API is vulnerable to SQL injection.
h) User Interface (UI) Testing
Definition: UI testing ensures that the graphical user interface works correctly, is user-friendly, and matches design specifications.
Goal: To test visual elements and user interactions.
Tools: Selenium, Cypress, TestCafe.
Example: Testing if the "Submit" button in a form behaves correctly when clicked.
i) Regression Testing
Definition: Regression testing ensures that new changes (like features or bug fixes) don't break existing functionality.
Goal: To validate that recent code changes haven't affected the overall functionality of the software.
Tools: PHPUnit, Selenium, Cypress.
Example: After adding a new feature, testing previously working features to ensure they still work as expected.
2. Common Testing Terms
Here are some common terms you'll encounter when working with testing:

Test Case: A set of conditions or variables used to test a particular feature or functionality of the application.
Test Suite: A collection of test cases that are executed together.
Mocking: Creating fake or simulated objects that mimic the behavior of real objects in the application for testing purposes.
Assertion: A statement in your test that verifies whether a condition is true or false. If the condition is false, the test fails.
Code Coverage: A measure of how much of your code is covered by tests. High code coverage means most of the codebase is tested.
Continuous Integration (CI): A practice where code changes are automatically tested as soon as they are committed to the version control system.
Test-Driven Development (TDD): A development approach where tests are written before the code itself, helping developers focus on writing clean, testable code.
Smoke Testing: A high-level type of testing to ensure the basic functionality of the system works without going into deep details.
3. Key Considerations for Effective Testing
When creating your testing strategy, consider the following:

a) Test Automation vs. Manual Testing
Automated Testing is useful for repetitive tests (like unit tests, regression tests, and performance tests). It improves efficiency and ensures tests are executed consistently.
Manual Testing is better for usability testing, exploratory testing, and one-off tests that require human insight.
b) Test Data Management
Create realistic test data to ensure your tests are representative of real-world scenarios. Avoid using sensitive or production data in your tests. Use anonymized or fake data when possible.
c) Environment Consistency
Ensure your tests run in an environment similar to production (e.g., identical versions of databases, servers, etc.). Test environments should mirror production to avoid discrepancies.
d) Parallel Testing
Running tests in parallel across multiple environments or machines speeds up the testing process and allows for testing at scale.
e) Test Maintenance
Over time, tests can become outdated due to code changes. Ensure tests are maintained regularly, especially when there are significant changes to the application.
f) Test Reporting and Feedback
Clear and detailed reports help identify issues and provide insights into test failures. Integrate test results into your CI pipeline and ensure feedback is fast and actionable.
g) Cross-Browser and Cross-Device Testing
For web applications, ensure tests cover different browsers (e.g., Chrome, Firefox, Safari) and devices (mobile and desktop) to ensure compatibility.
4. Best Practices for Testing
Keep Tests Small and Focused: Each test should focus on one specific functionality.
Write Readable Tests: Tests should be easy to read and understand, even for someone who didn’t write them.
Test Early and Often: Implement testing early in the development process and run tests frequently.
Use CI/CD Pipelines: Integrate testing into your continuous integration (CI) pipeline to ensure that tests are executed with each code change.
Maintain a Balance of Manual and Automated Testing: Automated tests are efficient, but manual testing is still required for exploratory and usability testing.


# DTOs, Types, and Static Analysis
with example

1. DTOs (Data Transfer Objects)
What is a DTO?
A Data Transfer Object (DTO) is an object used to transfer data between software application layers (e.g., between a backend service and the frontend). DTOs help to encapsulate data and avoid exposing domain models directly, which might contain business logic or sensitive information.

Purpose of DTOs:
Separation of Concerns: DTOs allow decoupling between the internal structure of the application (e.g., domain models) and the data exposed to other systems (e.g., APIs).
Performance: They often minimize the data transferred, only including the necessary fields.
Security: Prevents unnecessary or sensitive data from being exposed to external systems.
Data Transformation: They can act as a layer for transforming or sanitizing data between different system layers.
Example:
Suppose you have a User model with multiple fields (like password, email, name, etc.), but when returning a user's data in an API, you might want to exclude sensitive fields like password.

php
Copy
// User Model (Domain Model)
class User {
    public $id;
    public $name;
    public $email;
    public $password; // Sensitive data
}

// DTO for exposing user data to an API
class UserDTO {
    public $id;
    public $name;
    public $email;
    
    // Constructor to map data from the User Model
    public function __construct(User $user) {
        $this->id = $user->id;
        $this->name = $user->name;
        $this->email = $user->email;
    }
}
Usage: When you need to send user data over an API, you use UserDTO to ensure that only the required data is transferred and that sensitive fields like password are excluded.

php
Copy
$user = new User();  // Fetch user from database
$userDTO = new UserDTO($user);
return response()->json($userDTO);
DTO Benefits:
Decoupling: Internal representations are hidden from the external world.
Customization: You can customize what gets transferred, thus optimizing network calls.
Maintainability: DTOs help in maintaining better control over changes in the structure of the data.
2. Types in Software Development
What Are Types?
Types refer to a system that defines the structure and behavior of data, typically as part of programming languages. Types can be:

Primitive types: e.g., integers, strings, booleans, etc.
Composite types: e.g., arrays, lists, classes, etc.
Custom types: e.g., user-defined classes or interfaces.
In statically-typed languages (like TypeScript or Java), types are checked at compile time, reducing errors and increasing clarity.

Type System in Action:
Types ensure that the data is used correctly, as they define what operations are allowed for a particular kind of data.

Example (Using TypeScript):
typescript
Copy
// Primitive type
let age: number = 25;
let isActive: boolean = true;

// Custom type using interface
interface User {
    id: number;
    name: string;
    email: string;
}

const user: User = {
    id: 1,
    name: "Alice",
    email: "alice@example.com"
};
Benefits of Types:
Type Safety: Types help catch errors early, preventing you from performing invalid operations (e.g., adding a number to a string).
Clarity: Makes it clear what kind of data you're dealing with, improving code readability.
Refactoring: Easier to refactor code safely when types are strictly defined.
3. Static Analysis
What is Static Analysis?
Static analysis refers to the examination of code without executing it. This is typically done using tools that analyze the source code to detect potential issues, such as bugs, code smells, or security vulnerabilities.

Static Analysis Goals:
Catch bugs early: Identify potential runtime issues at compile time.
Enforce coding standards: Ensure that the code adheres to predefined style guides and best practices.
Improve code quality: Find areas of the codebase that are inefficient, redundant, or prone to errors.
Example of Static Analysis Tools:
PHPStan and Psalm for PHP.
ESLint for JavaScript/TypeScript.
SonarQube for various languages.
Pylint for Python.
Example:
Consider the following PHP code with potential issues:

php
Copy
function addNumbers($a, $b) {
    return $a + $b;
}

$sum = addNumbers("1", "2"); // Passing strings, which could lead to unexpected results
Running PHPStan or Psalm will catch this and warn you about the type mismatch or unexpected behavior due to adding strings instead of numbers.

Benefits of Static Analysis:
Early Detection: Identifies issues such as uninitialized variables, undefined functions, type mismatches, etc.
Consistency: Ensures the code follows style guidelines and best practices.
Security: Detects potential security vulnerabilities (e.g., SQL injection, cross-site scripting) before the code is deployed.
Integrating DTOs, Types, and Static Analysis in a Project
Example Scenario: User Registration API
DTOs: Create a UserDTO that contains only the fields required to register a user, ensuring no sensitive information is exposed.

Types: Define types for both incoming data (e.g., request body) and outgoing data (e.g., API response).

Static Analysis: Use static analysis tools to enforce rules around types and catch potential issues such as missing parameters, type mismatches, or other logic errors.

Example Code:

// User Registration DTO
class UserRegisterDTO {
    public $name;
    public $email;
    public $password;

    public function __construct($name, $email, $password) {
        $this->name = $name;
        $this->email = $email;
        $this->password = $password;
    }
}

// User Controller to handle registration
class UserController {
    public function register(Request $request) {
        // Validate incoming data using DTO
        $userDTO = new UserRegisterDTO($request->name, $request->email, $request->password);
        
        // Static analysis will detect that all required fields are passed in and correctly typed
        
        // Process user registration logic here
        // For example, save user to the database
    }
}
Static Analysis Setup:
You would run static analysis tools like PHPStan or Psalm on your codebase:

vendor/bin/phpstan analyse src

This ensures that all code follows the correct types and logic and that there are no runtime issues or errors before deploying your application.

// Dependencies, Coupling, and Interfaces

What Are Dependencies and Coupling?
Think of dependencies like relationships between different parts of your application. Just as a car engine depends on fuel to run, your PHP classes often depend on other classes to function properly.

Coupling refers to how tightly these relationships are connected. Imagine two dance partners:

Loose coupling is like ballroom dancing — partners can easily switch and adapt
Tight coupling is like synchronized swimming — partners are strictly bound together
Why Should You Care About Dependencies and Interfaces?
Maintainability: Easier to update individual components
Testability: Simpler to write unit tests
Flexibility: Swap implementations without changing code
Scalability: Add new features without breaking existing code
Code Quality: Better organization and cleaner architecture


#Using Interfaces for Loose Coupling (The Right Way)
interface NotifierInterface
{
    public function sendNotification(string $recipient, string $message): void;
}

class EmailNotifier implements NotifierInterface
{
    public function sendNotification(string $recipient, string $message): void
    {
        // Send email logic
        echo "Sending email to {$recipient}: {$message}";
    }
}

class SMSNotifier implements NotifierInterface
{
    public function sendNotification(string $recipient, string $message): void
    {
        // Send SMS logic
        echo "Sending SMS to {$recipient}: {$message}";
    }
}

class OrderProcessor
{
    public function __construct(
        private NotifierInterface $notifier
    ) {}
    
    public function processOrder(Order $order): void
    {
        // Process order
        $this->notifier->sendNotification(
            $order->getCustomerContact(),
            "Your order #{$order->getId()} has been processed!"
        );
    }
}

//Interfaces as Feature Filters

Why Use Interfaces as Feature Filters?
Clear Feature Sets
Explicitly define available features
Make capabilities obvious at a glance
Improve code readability
Type Safety
Guarantee feature availability
Catch missing implementations early
Reduce runtime errors
Flexible Architecture
Mix and match features
Easy feature addition
Simple capability checking
How to Implement Interface Feature Filters in PHP 8.4
Let’s learn through practical examples by building a media player system.

1. Basic Interface Structure
interface Playable
{
    public function play(): void;
    public function pause(): void;
    public function stop(): void;
}

interface HasVolume
{
    public function setVolume(int $level): void;
    public function getVolume(): int;
}

interface Seekable
{
    public function seekTo(int $position): void;
    public function getCurrentPosition(): int;
}


// Encapsulation and Visiblity in php

    What is Encapsulation in PHP?
    Think of encapsulation like a secure vault in a bank. Just as a vault protects valuable assets and controls access through specific procedures, encapsulation in PHP:

    Bundles related data and methods together
    Controls access to class members
    Protects internal implementation details


    How to Implement Encapsulation in PHP 8.4
    Let’s learn through practical examples by building a banking system.

    1. Basic Encapsulation Structure
    class BankAccount
    {
        private float $balance = 0;
        
        public function __construct(
            private string $accountNumber,
            private string $accountType = 'savings'
        ) {
            //
        }
        
        public function getBalance(): float
        {
            return $this->balance;
        }
        
        public function deposit(float $amount): bool
        {
            if ($amount > 0) {
                $this->balance += $amount;
                return true;
            }
            return false;
        }
        
        public function withdraw(float $amount): bool
        {
            if ($amount > 0 && $this->balance >= $amount) {
                $this->balance -= $amount;
                return true;
            }
            return false;
        }
    }
    2. Understanding Visibility Modifiers

    class Customer
    {
        // Only accessible within this class
        private string $socialSecurityNumber;
        
        // Accessible within this class and child classes
        protected string $customerType;
        
        // Accessible from anywhere
        public string $name;
        
        private function validateSSN(string $ssn): bool
        {
            // Internal validation logic
            return (bool) preg_match('/^\d{3}-\d{2}-\d{4}$/', $ssn);
        }
        
        public function setSSN(string $ssn): bool
        {
            if ($this->validateSSN($ssn)) {
                $this->socialSecurityNumber = $ssn;
                return true;
            }
            return false;
        }
    }

 // Understanding Property Hooks
Property hooks are specialized methods that intercept property access and modification, providing a direct, intuitive way to manage class properties. Unlike traditional getter and setter methods, property hooks offer a seamless mechanism to control property interactions with built-in type safety and validation.

Key Benefits of Property Hooks
Simplified Syntax: Eliminate verbose getter and setter methods
Enhanced Encapsulation: Maintain strict control over property access
Improved Type Safety: Leverage built-in type checking
Better Performance: Achieve direct property-like access with robust validation
Practical Implementation
Let’s dive into a concrete example that illustrates the power of property hooks. Consider a BankAccount class that requires sophisticated balance management:

class BankAccount {
    public get float $balance {
        return $this->_balance * $this->exchangeRate;
    }
    
    public set float $balance {
        if ($value < 0) {
            throw new InvalidArgumentException('Balance cannot be negative');
        }
        $this->_balance = $value;
    }
    
    private float $_balance = 0;
    private float $exchangeRate = 1.0;
}

//Eloquent Relationships- Has-one-through

The "has-one-through" relationship defines a one-to-one relationship with another model. However, this relationship indicates that the declaring model can be matched with one instance of another model by proceeding through a third model.

For example, in a vehicle repair shop application, each Mechanic model may be associated with one Car model, and each Car model may be associated with one Owner model. While the mechanic and the owner have no direct relationship within the database, the mechanic can access the owner through the Car model. Let's look at the tables necessary to define this relationship:

mechanics
    id - integer
    name - string
 
cars
    id - integer
    model - string
    mechanic_id - integer
 
owners
    id - integer
    name - string
    car_id - integer

Now that we have examined the table structure for the relationship, let's define the relationship on the Mechanic model:

<?php
 
namespace App\Models;
 
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasOneThrough;
 
class Mechanic extends Model
{
    /**
     * Get the car's owner.
     */
    public function carOwner(): HasOneThrough
    {
        return $this->hasOneThrough(Owner::class, Car::class);
    }
}


//code demonstrates how to use accessors and mutators in Laravel with Eloquent models, 
leveraging the new Attribute class introduced in Laravel.

<?php
 
namespace App\Models;
 
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Eloquent\Model;
 
class User extends Model
{
    /**
     * Interact with the user's first name.
     */
    protected function firstName(): Attribute
    {
        return Attribute::make(
            get: fn (string $value) => ucfirst($value),
            set: fn (string $value) => strtolower($value),
        );
    }
}


The Strategy and Factory patterns are both creational design patterns, but they serve different purposes.

The Strategy pattern is used to define a family of algorithms, encapsulate each one, and make them interchangeable. It allows the algorithm to vary independently from the clients that use it. In the provided code, the TransactionContext class represents the context that uses different strategies (IncomeTransaction and ExpenseTransaction) based on the CategoryTypeEnum. The TransactionContext class has a store method that delegates the actual storing logic to the selected strategy.

On the other hand, the Factory pattern is used to create objects without specifying the exact class of the object that will be created. It provides an interface for creating objects, but allows subclasses to decide which class to instantiate. In the provided code, the TransactionFactory class is responsible for creating the appropriate transaction object based on the CategoryTypeEnum. The initialize method of the TransactionFactory class returns an instance of the appropriate transaction class.

To summarize:

The Strategy pattern is used to define interchangeable algorithms and allows the client to select the algorithm at runtime.
The Factory pattern is used to create objects without specifying the exact class and allows subclasses to decide which class to instantiate.

//Better encapsulation in Laravel

Encapsulation Using Services
You can create service classes in Laravel to encapsulate business logic. 
This keeps your controllers clean and focused on handling HTTP requests.
 Encapsulation in OOP and Laravel involves: Private and 
 Protected Members: Restricting access to internal properties and methods.

 This directory does not exist by default, but will be created for you 
 if you execute the make:rule Artisan command. 
 The Rules directory contains the custom validation rule objects for your application. 
 Rules are used to encapsulate complicated validation logic in a simple object.


 //Measuring Your Database Performance eloquent
 To measure database performance within an Eloquent application (Laravel), 
 you can primarily focus on analyzing query execution times, utilizing Laravel's built-in debugging tools 
 like the "Debugbar" to identify slow queries, and optimizing your Eloquent relationships 
 and query structures by checking for potential "N+1" query problems, eager loading, 
 and proper indexing on your database tables. 

 //Minimize Memory Usage
To minimize memory usage when working with Eloquent in Laravel, focus on fetching only the necessary data columns by using the select method, leverage eager loading with with() to avoid N+1 query issues, and utilize techniques like chunking (chunk()) to process large datasets in smaller batches, preventing overloading of memory. 
Key strategies to minimize Eloquent memory usage:
Select specific columns:
Use select('column1', 'column2') to retrieve only the required columns from the database, instead of using select('*') which fetches all columns. 
Eager loading:
When querying related models, use with() to load them in a single query, preventing unnecessary database round trips and reducing memory usage. 
Lazy loading:
Consider using lazy collections (introduced in Laravel 6+) to load related data only when needed, further optimizing memory usage for large datasets. 
Chunking:
For very large result sets, use the chunk() method to process data in smaller batches, which can significantly reduce memory consumption.

//Getting One Record From a Has-Many Relationship

If the laravel app contains 2 models, Say Order and OrderStatus.
By Using the Order model relationship, we can acheive the result.

This will fetch only the latest status of the Order.
eg: App\Models\Order
public function CurrentStatus(): HasOne
{
    return $this->HasOne(OrderStatus::class)
     ->latestOfMany();
}

//Dynamic Relationships Using Subqueries

Subqueries allow us to select extra columns (attributes) right in our database query (the users query in our example).
 Let's look at how we can do this.

$users = User::query()
    ->addSelect(['last_login_at' => Login::select('created_at')
        ->whereColumn('user_id', 'users.id')
        ->latest()
        ->take(1)
    ])
    ->withCasts(['last_login_at' => 'datetime'])
    ->get();

@foreach ($users as $user)
    <tr>
        <td>{{ $user->name }}</td>
        <td>{{ $user->email }}</td>
        <td>
            @if ($user->last_login_at)
                {{ $user->last_login_at->format('M j, Y \a\t g:i a') }}
            @else
                Never
            @endif
        </td>
    </tr>
@endforeach
select
    "users".*,
    (
        select "created_at" from "logins"
        where "user_id" = "users"."id"
        order by "created_at" desc
        limit 1
    ) as "last_login_at"
from "users";


Using a subquery in this way allows us to get all the information we need for our users page in a single query. 
This technique provides huge performance wins, since we can keep both our database queries and memory usage to a minimum,
 plus we've avoided having to use caching.

 // Conditional aggregates
There's actually a really simple way to calculate these totals using a single database query. The trick is to put conditions within aggregate functions. Here's an example in SQL:

select
  count(*) as total,
  count(case when status = 'confirmed' then 1 end) as confirmed,
  count(case when status = 'unconfirmed' then 1 end) as unconfirmed,
  count(case when status = 'cancelled' then 1 end) as cancelled,
  count(case when status = 'bounced' then 1 end) as bounced
from subscribers

 total | confirmed | unconfirmed | cancelled | bounced
-------+-----------+-------------+-----------+---------
   200 |       150 |          50 |        30 |      25

Here's how you can write this query in Laravel using the query builder:

$totals = DB::table('subscribers')
    ->selectRaw('count(*) as total')
    ->selectRaw("count(case when status = 'confirmed' then 1 end) as confirmed")
    ->selectRaw("count(case when status = 'unconfirmed' then 1 end) as unconfirmed")
    ->selectRaw("count(case when status = 'cancelled' then 1 end) as cancelled")
    ->selectRaw("count(case when status = 'bounced' then 1 end) as bounced")
    ->first();

//What are circular relationships?
So what exactly are circular relationships? In a way, all relationships are circular. 
Consider a User and an Account. A user belongs to an account, and an account has many users. 
Another example is a Product and a Category. A product belongs to a category, and a category has many products. 
They are circular because they "point" to each other.

Here's how you might define this in Laravel:

class Product extends Model
{
    public function category()
    {
        return $this->belongsTo(Category::class);
    }
}

class Category extends Model
{
    public function products()
    {
        return $this->hasMany(Product::class);
    }
}
Now, typically you don't access both sides of a relationship in the same endpoint. 
For example, if you visit a product category page, you'll load all the products for that category. 
However, you likely won't load all the categories for those products, since you're already on the category page.

//Multi-Column Searching eloquent

Using where and orWhere
If you want to search across multiple columns with different conditions, you can chain where and orWhere:

php
Copy
$search = 'example';  // The term you are searching for

$results = Model::where('column1', 'like', "%$search%")
                ->orWhere('column2', 'like', "%$search%")
                ->orWhere('column3', 'like', "%$search%")
                ->get();
This query will search for the $search term in column1, column2, and column3.

2. Using where with orWhere inside a closure
If you have multiple conditions for different columns and need more control over grouping them, you can use a closure inside the where method:

php
Copy
$search = 'example';

$results = Model::where(function($query) use ($search) {
                    $query->where('column1', 'like', "%$search%")
                          ->orWhere('column2', 'like', "%$search%")
                          ->orWhere('column3', 'like', "%$search%");
                })
                ->get();
This ensures that all orWhere conditions are grouped together in one set of parentheses.

// Associative Array
An associative array uses named keys to store values.

<?php
// Creating an associative array
$person = array(
    "name" => "John",
    "age" => 30,
    "city" => "New York"
);

// Accessing elements by key
echo $person["name"]; // Output: John
echo $person["age"];  // Output: 30
echo $person["city"]; // Output: New York
?>

//Basic Lambda Function

In PHP, a lambda function (also called an anonymous function) is a function that does not have a name 
and can be created inline. You can use lambda functions in many scenarios like callbacks, filtering, 
or other functional programming tasks.

Here's an example of how to use lambda functions in PHP:

<?php
// Defining a simple lambda function
$square = function($x) {
    return $x * $x;
};

// Using the lambda function
echo $square(5); // Output: 25
?>


//Faster Options Than whereHas
$variant = Variant::first(); // Use this variant to search by name

// whereHas
Product::whereHas('variants', function ($query) use ($variant) {
            $query->where('name', $variant->name);
        })->get(); // 11.46ms
// join
Product::select('products.*')
    ->join('variants', function ($query) use ($variant){
        $query->on('variants.product_id', '=', 'products.id')
              ->where('variants.name', $variant->name);
    })->get(); // 1.89ms

So I would keep using whereHas for the readability if I'm working with a dataset where the results 
will fetch most of the rows on my target model or if the amount of records in the database is small enough that the impact of changing that query 
to a join would be minimal.

On the other hand, I would use a join if I'm working with a big database and the conditions would 
retrieve only a small subset of the records in my database.

//Use Unions to Run Queries Independently
Key Concepts:
union: Combines the results of multiple queries, excluding duplicate rows.
unionAll: Combines the results of multiple queries, including duplicate rows.
Example: Using union to Combine Queries Independently
Imagine you have two different tables or queries, and you want to combine their results.

Scenario: You have two queries—one to fetch users from the users table and another 
to fetch customers from the customers table. Both queries return similar data (e.g., name, email), 
and you want to combine these results into one collection.

<?php

use App\Models\User;
use App\Models\Customer;
use Illuminate\Support\Facades\DB;

// First query: Getting users
$query1 = User::select('name', 'email')
             ->where('status', 'active');

// Second query: Getting customers
$query2 = Customer::select('name', 'email')
                  ->where('status', 'active');

// Combine results using union
$combinedResults = $query1->union($query2)->get();

// Optionally, you can use `unionAll` to include duplicates:
$combinedResultsIncludingDuplicates = $query1->unionAll($query2)->get();

// Return or display the combined results
return $combinedResults;
?>