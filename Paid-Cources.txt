
#Testing Approaches, Terms, and Considerations

When it comes to testing in software development, several approaches, terms, and considerations come into play, depending on the type of application you're building (e.g., web, API, mobile). Below is a breakdown to help you understand key concepts, testing methodologies, and things to keep in mind when creating a testing strategy for your application.

1. Testing Approaches
These are different levels of testing that help ensure the software is functioning as expected.

a) Unit Testing
Definition: Unit testing involves testing individual units of code (such as a single function or method) in isolation.
Goal: To verify that each part of the code works as expected.
Tools: PHPUnit (for PHP), Jest (for JavaScript), JUnit (for Java).
Example: Testing a function that calculates the sum of two numbers.
b) Integration Testing
Definition: Integration tests check if multiple modules or components of the system work together as expected.
Goal: To ensure that the system components interact correctly.
Tools: PHPUnit (for PHP), Mocha (for JavaScript).
Example: Testing a function that interacts with the database or an external API.
c) Functional Testing
Definition: Functional tests focus on verifying the functionality of the system as a whole, often in terms of user stories or business requirements.
Goal: To ensure the system behaves according to specified requirements.
Tools: Selenium, Cypress, Laravel Dusk.
Example: Testing the login process of a website.
d) End-to-End (E2E) Testing
Definition: E2E testing simulates a user journey from start to finish to ensure the application works as intended when all parts are integrated.
Goal: To test the complete flow of the application, from front-end to back-end.
Tools: Cypress, Selenium, TestCafe.
Example: Testing the entire e-commerce checkout process.
e) Acceptance Testing
Definition: Acceptance tests ensure the software meets the business requirements and is ready for release.
Goal: To validate the software against business or functional requirements.
Tools: Cucumber, Behat.
Example: Testing if a feature like password reset works as expected by the product owner’s specifications.
f) Performance Testing
Definition: Performance testing is focused on determining how the system performs under load, including how it handles high traffic or large amounts of data.
Types:
Load Testing: To check how the system handles expected load.
Stress Testing: To check how the system behaves under extreme conditions (overload).
Scalability Testing: To see how the system scales as demand increases.
Tools: Apache JMeter, LoadRunner.
Example: Testing how a website performs when 10,000 users are trying to access it simultaneously.
g) Security Testing
Definition: Security testing ensures the system is protected against unauthorized access, data breaches, and other vulnerabilities.
Goal: To verify that the software is secure from common threats like SQL injection, XSS, and other vulnerabilities.
Tools: OWASP ZAP, Burp Suite.
Example: Testing if an API is vulnerable to SQL injection.
h) User Interface (UI) Testing
Definition: UI testing ensures that the graphical user interface works correctly, is user-friendly, and matches design specifications.
Goal: To test visual elements and user interactions.
Tools: Selenium, Cypress, TestCafe.
Example: Testing if the "Submit" button in a form behaves correctly when clicked.
i) Regression Testing
Definition: Regression testing ensures that new changes (like features or bug fixes) don't break existing functionality.
Goal: To validate that recent code changes haven't affected the overall functionality of the software.
Tools: PHPUnit, Selenium, Cypress.
Example: After adding a new feature, testing previously working features to ensure they still work as expected.
2. Common Testing Terms
Here are some common terms you'll encounter when working with testing:

Test Case: A set of conditions or variables used to test a particular feature or functionality of the application.
Test Suite: A collection of test cases that are executed together.
Mocking: Creating fake or simulated objects that mimic the behavior of real objects in the application for testing purposes.
Assertion: A statement in your test that verifies whether a condition is true or false. If the condition is false, the test fails.
Code Coverage: A measure of how much of your code is covered by tests. High code coverage means most of the codebase is tested.
Continuous Integration (CI): A practice where code changes are automatically tested as soon as they are committed to the version control system.
Test-Driven Development (TDD): A development approach where tests are written before the code itself, helping developers focus on writing clean, testable code.
Smoke Testing: A high-level type of testing to ensure the basic functionality of the system works without going into deep details.
3. Key Considerations for Effective Testing
When creating your testing strategy, consider the following:

a) Test Automation vs. Manual Testing
Automated Testing is useful for repetitive tests (like unit tests, regression tests, and performance tests). It improves efficiency and ensures tests are executed consistently.
Manual Testing is better for usability testing, exploratory testing, and one-off tests that require human insight.
b) Test Data Management
Create realistic test data to ensure your tests are representative of real-world scenarios. Avoid using sensitive or production data in your tests. Use anonymized or fake data when possible.
c) Environment Consistency
Ensure your tests run in an environment similar to production (e.g., identical versions of databases, servers, etc.). Test environments should mirror production to avoid discrepancies.
d) Parallel Testing
Running tests in parallel across multiple environments or machines speeds up the testing process and allows for testing at scale.
e) Test Maintenance
Over time, tests can become outdated due to code changes. Ensure tests are maintained regularly, especially when there are significant changes to the application.
f) Test Reporting and Feedback
Clear and detailed reports help identify issues and provide insights into test failures. Integrate test results into your CI pipeline and ensure feedback is fast and actionable.
g) Cross-Browser and Cross-Device Testing
For web applications, ensure tests cover different browsers (e.g., Chrome, Firefox, Safari) and devices (mobile and desktop) to ensure compatibility.
4. Best Practices for Testing
Keep Tests Small and Focused: Each test should focus on one specific functionality.
Write Readable Tests: Tests should be easy to read and understand, even for someone who didn’t write them.
Test Early and Often: Implement testing early in the development process and run tests frequently.
Use CI/CD Pipelines: Integrate testing into your continuous integration (CI) pipeline to ensure that tests are executed with each code change.
Maintain a Balance of Manual and Automated Testing: Automated tests are efficient, but manual testing is still required for exploratory and usability testing.


# DTOs, Types, and Static Analysis
with example

1. DTOs (Data Transfer Objects)
What is a DTO?
A Data Transfer Object (DTO) is an object used to transfer data between software application layers (e.g., between a backend service and the frontend). DTOs help to encapsulate data and avoid exposing domain models directly, which might contain business logic or sensitive information.

Purpose of DTOs:
Separation of Concerns: DTOs allow decoupling between the internal structure of the application (e.g., domain models) and the data exposed to other systems (e.g., APIs).
Performance: They often minimize the data transferred, only including the necessary fields.
Security: Prevents unnecessary or sensitive data from being exposed to external systems.
Data Transformation: They can act as a layer for transforming or sanitizing data between different system layers.
Example:
Suppose you have a User model with multiple fields (like password, email, name, etc.), but when returning a user's data in an API, you might want to exclude sensitive fields like password.

php
Copy
// User Model (Domain Model)
class User {
    public $id;
    public $name;
    public $email;
    public $password; // Sensitive data
}

// DTO for exposing user data to an API
class UserDTO {
    public $id;
    public $name;
    public $email;
    
    // Constructor to map data from the User Model
    public function __construct(User $user) {
        $this->id = $user->id;
        $this->name = $user->name;
        $this->email = $user->email;
    }
}
Usage: When you need to send user data over an API, you use UserDTO to ensure that only the required data is transferred and that sensitive fields like password are excluded.

php
Copy
$user = new User();  // Fetch user from database
$userDTO = new UserDTO($user);
return response()->json($userDTO);
DTO Benefits:
Decoupling: Internal representations are hidden from the external world.
Customization: You can customize what gets transferred, thus optimizing network calls.
Maintainability: DTOs help in maintaining better control over changes in the structure of the data.
2. Types in Software Development
What Are Types?
Types refer to a system that defines the structure and behavior of data, typically as part of programming languages. Types can be:

Primitive types: e.g., integers, strings, booleans, etc.
Composite types: e.g., arrays, lists, classes, etc.
Custom types: e.g., user-defined classes or interfaces.
In statically-typed languages (like TypeScript or Java), types are checked at compile time, reducing errors and increasing clarity.

Type System in Action:
Types ensure that the data is used correctly, as they define what operations are allowed for a particular kind of data.

Example (Using TypeScript):
typescript
Copy
// Primitive type
let age: number = 25;
let isActive: boolean = true;

// Custom type using interface
interface User {
    id: number;
    name: string;
    email: string;
}

const user: User = {
    id: 1,
    name: "Alice",
    email: "alice@example.com"
};
Benefits of Types:
Type Safety: Types help catch errors early, preventing you from performing invalid operations (e.g., adding a number to a string).
Clarity: Makes it clear what kind of data you're dealing with, improving code readability.
Refactoring: Easier to refactor code safely when types are strictly defined.
3. Static Analysis
What is Static Analysis?
Static analysis refers to the examination of code without executing it. This is typically done using tools that analyze the source code to detect potential issues, such as bugs, code smells, or security vulnerabilities.

Static Analysis Goals:
Catch bugs early: Identify potential runtime issues at compile time.
Enforce coding standards: Ensure that the code adheres to predefined style guides and best practices.
Improve code quality: Find areas of the codebase that are inefficient, redundant, or prone to errors.
Example of Static Analysis Tools:
PHPStan and Psalm for PHP.
ESLint for JavaScript/TypeScript.
SonarQube for various languages.
Pylint for Python.
Example:
Consider the following PHP code with potential issues:

php
Copy
function addNumbers($a, $b) {
    return $a + $b;
}

$sum = addNumbers("1", "2"); // Passing strings, which could lead to unexpected results
Running PHPStan or Psalm will catch this and warn you about the type mismatch or unexpected behavior due to adding strings instead of numbers.

Benefits of Static Analysis:
Early Detection: Identifies issues such as uninitialized variables, undefined functions, type mismatches, etc.
Consistency: Ensures the code follows style guidelines and best practices.
Security: Detects potential security vulnerabilities (e.g., SQL injection, cross-site scripting) before the code is deployed.
Integrating DTOs, Types, and Static Analysis in a Project
Example Scenario: User Registration API
DTOs: Create a UserDTO that contains only the fields required to register a user, ensuring no sensitive information is exposed.

Types: Define types for both incoming data (e.g., request body) and outgoing data (e.g., API response).

Static Analysis: Use static analysis tools to enforce rules around types and catch potential issues such as missing parameters, type mismatches, or other logic errors.

Example Code:

// User Registration DTO
class UserRegisterDTO {
    public $name;
    public $email;
    public $password;

    public function __construct($name, $email, $password) {
        $this->name = $name;
        $this->email = $email;
        $this->password = $password;
    }
}

// User Controller to handle registration
class UserController {
    public function register(Request $request) {
        // Validate incoming data using DTO
        $userDTO = new UserRegisterDTO($request->name, $request->email, $request->password);
        
        // Static analysis will detect that all required fields are passed in and correctly typed
        
        // Process user registration logic here
        // For example, save user to the database
    }
}
Static Analysis Setup:
You would run static analysis tools like PHPStan or Psalm on your codebase:

vendor/bin/phpstan analyse src

This ensures that all code follows the correct types and logic and that there are no runtime issues or errors before deploying your application.

// Dependencies, Coupling, and Interfaces

What Are Dependencies and Coupling?
Think of dependencies like relationships between different parts of your application. Just as a car engine depends on fuel to run, your PHP classes often depend on other classes to function properly.

Coupling refers to how tightly these relationships are connected. Imagine two dance partners:

Loose coupling is like ballroom dancing — partners can easily switch and adapt
Tight coupling is like synchronized swimming — partners are strictly bound together
Why Should You Care About Dependencies and Interfaces?
Maintainability: Easier to update individual components
Testability: Simpler to write unit tests
Flexibility: Swap implementations without changing code
Scalability: Add new features without breaking existing code
Code Quality: Better organization and cleaner architecture


#Using Interfaces for Loose Coupling (The Right Way)
interface NotifierInterface
{
    public function sendNotification(string $recipient, string $message): void;
}

class EmailNotifier implements NotifierInterface
{
    public function sendNotification(string $recipient, string $message): void
    {
        // Send email logic
        echo "Sending email to {$recipient}: {$message}";
    }
}

class SMSNotifier implements NotifierInterface
{
    public function sendNotification(string $recipient, string $message): void
    {
        // Send SMS logic
        echo "Sending SMS to {$recipient}: {$message}";
    }
}

class OrderProcessor
{
    public function __construct(
        private NotifierInterface $notifier
    ) {}
    
    public function processOrder(Order $order): void
    {
        // Process order
        $this->notifier->sendNotification(
            $order->getCustomerContact(),
            "Your order #{$order->getId()} has been processed!"
        );
    }
}

//Interfaces as Feature Filters

Why Use Interfaces as Feature Filters?
Clear Feature Sets
Explicitly define available features
Make capabilities obvious at a glance
Improve code readability
Type Safety
Guarantee feature availability
Catch missing implementations early
Reduce runtime errors
Flexible Architecture
Mix and match features
Easy feature addition
Simple capability checking
How to Implement Interface Feature Filters in PHP 8.4
Let’s learn through practical examples by building a media player system.

1. Basic Interface Structure
interface Playable
{
    public function play(): void;
    public function pause(): void;
    public function stop(): void;
}

interface HasVolume
{
    public function setVolume(int $level): void;
    public function getVolume(): int;
}

interface Seekable
{
    public function seekTo(int $position): void;
    public function getCurrentPosition(): int;
}


// Encapsulation and Visiblity in php

    What is Encapsulation in PHP?
    Think of encapsulation like a secure vault in a bank. Just as a vault protects valuable assets and controls access through specific procedures, encapsulation in PHP:

    Bundles related data and methods together
    Controls access to class members
    Protects internal implementation details


    How to Implement Encapsulation in PHP 8.4
    Let’s learn through practical examples by building a banking system.

    1. Basic Encapsulation Structure
    class BankAccount
    {
        private float $balance = 0;
        
        public function __construct(
            private string $accountNumber,
            private string $accountType = 'savings'
        ) {
            //
        }
        
        public function getBalance(): float
        {
            return $this->balance;
        }
        
        public function deposit(float $amount): bool
        {
            if ($amount > 0) {
                $this->balance += $amount;
                return true;
            }
            return false;
        }
        
        public function withdraw(float $amount): bool
        {
            if ($amount > 0 && $this->balance >= $amount) {
                $this->balance -= $amount;
                return true;
            }
            return false;
        }
    }
    2. Understanding Visibility Modifiers

    class Customer
    {
        // Only accessible within this class
        private string $socialSecurityNumber;
        
        // Accessible within this class and child classes
        protected string $customerType;
        
        // Accessible from anywhere
        public string $name;
        
        private function validateSSN(string $ssn): bool
        {
            // Internal validation logic
            return (bool) preg_match('/^\d{3}-\d{2}-\d{4}$/', $ssn);
        }
        
        public function setSSN(string $ssn): bool
        {
            if ($this->validateSSN($ssn)) {
                $this->socialSecurityNumber = $ssn;
                return true;
            }
            return false;
        }
    }

 // Understanding Property Hooks
Property hooks are specialized methods that intercept property access and modification, providing a direct, intuitive way to manage class properties. Unlike traditional getter and setter methods, property hooks offer a seamless mechanism to control property interactions with built-in type safety and validation.

Key Benefits of Property Hooks
Simplified Syntax: Eliminate verbose getter and setter methods
Enhanced Encapsulation: Maintain strict control over property access
Improved Type Safety: Leverage built-in type checking
Better Performance: Achieve direct property-like access with robust validation
Practical Implementation
Let’s dive into a concrete example that illustrates the power of property hooks. Consider a BankAccount class that requires sophisticated balance management:

class BankAccount {
    public get float $balance {
        return $this->_balance * $this->exchangeRate;
    }
    
    public set float $balance {
        if ($value < 0) {
            throw new InvalidArgumentException('Balance cannot be negative');
        }
        $this->_balance = $value;
    }
    
    private float $_balance = 0;
    private float $exchangeRate = 1.0;
}

//Eloquent Relationships- Has-one-through

The "has-one-through" relationship defines a one-to-one relationship with another model. However, this relationship indicates that the declaring model can be matched with one instance of another model by proceeding through a third model.

For example, in a vehicle repair shop application, each Mechanic model may be associated with one Car model, and each Car model may be associated with one Owner model. While the mechanic and the owner have no direct relationship within the database, the mechanic can access the owner through the Car model. Let's look at the tables necessary to define this relationship:

mechanics
    id - integer
    name - string
 
cars
    id - integer
    model - string
    mechanic_id - integer
 
owners
    id - integer
    name - string
    car_id - integer

Now that we have examined the table structure for the relationship, let's define the relationship on the Mechanic model:

<?php
 
namespace App\Models;
 
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasOneThrough;
 
class Mechanic extends Model
{
    /**
     * Get the car's owner.
     */
    public function carOwner(): HasOneThrough
    {
        return $this->hasOneThrough(Owner::class, Car::class);
    }
}


//code demonstrates how to use accessors and mutators in Laravel with Eloquent models, 
leveraging the new Attribute class introduced in Laravel.

<?php
 
namespace App\Models;
 
use Illuminate\Database\Eloquent\Casts\Attribute;
use Illuminate\Database\Eloquent\Model;
 
class User extends Model
{
    /**
     * Interact with the user's first name.
     */
    protected function firstName(): Attribute
    {
        return Attribute::make(
            get: fn (string $value) => ucfirst($value),
            set: fn (string $value) => strtolower($value),
        );
    }
}


The Strategy and Factory patterns are both creational design patterns, but they serve different purposes.

The Strategy pattern is used to define a family of algorithms, encapsulate each one, and make them interchangeable. It allows the algorithm to vary independently from the clients that use it. In the provided code, the TransactionContext class represents the context that uses different strategies (IncomeTransaction and ExpenseTransaction) based on the CategoryTypeEnum. The TransactionContext class has a store method that delegates the actual storing logic to the selected strategy.

On the other hand, the Factory pattern is used to create objects without specifying the exact class of the object that will be created. It provides an interface for creating objects, but allows subclasses to decide which class to instantiate. In the provided code, the TransactionFactory class is responsible for creating the appropriate transaction object based on the CategoryTypeEnum. The initialize method of the TransactionFactory class returns an instance of the appropriate transaction class.

To summarize:

The Strategy pattern is used to define interchangeable algorithms and allows the client to select the algorithm at runtime.
The Factory pattern is used to create objects without specifying the exact class and allows subclasses to decide which class to instantiate.

//Better encapsulation in Laravel

Encapsulation Using Services
You can create service classes in Laravel to encapsulate business logic. 
This keeps your controllers clean and focused on handling HTTP requests.
 Encapsulation in OOP and Laravel involves: Private and 
 Protected Members: Restricting access to internal properties and methods.

 This directory does not exist by default, but will be created for you 
 if you execute the make:rule Artisan command. 
 The Rules directory contains the custom validation rule objects for your application. 
 Rules are used to encapsulate complicated validation logic in a simple object.


 //Measuring Your Database Performance eloquent
 To measure database performance within an Eloquent application (Laravel), 
 you can primarily focus on analyzing query execution times, utilizing Laravel's built-in debugging tools 
 like the "Debugbar" to identify slow queries, and optimizing your Eloquent relationships 
 and query structures by checking for potential "N+1" query problems, eager loading, 
 and proper indexing on your database tables. 

 //Minimize Memory Usage
To minimize memory usage when working with Eloquent in Laravel, focus on fetching only the necessary data columns by using the select method, leverage eager loading with with() to avoid N+1 query issues, and utilize techniques like chunking (chunk()) to process large datasets in smaller batches, preventing overloading of memory. 
Key strategies to minimize Eloquent memory usage:
Select specific columns:
Use select('column1', 'column2') to retrieve only the required columns from the database, instead of using select('*') which fetches all columns. 
Eager loading:
When querying related models, use with() to load them in a single query, preventing unnecessary database round trips and reducing memory usage. 
Lazy loading:
Consider using lazy collections (introduced in Laravel 6+) to load related data only when needed, further optimizing memory usage for large datasets. 
Chunking:
For very large result sets, use the chunk() method to process data in smaller batches, which can significantly reduce memory consumption.

//Getting One Record From a Has-Many Relationship

If the laravel app contains 2 models, Say Order and OrderStatus.
By Using the Order model relationship, we can acheive the result.

This will fetch only the latest status of the Order.
eg: App\Models\Order
public function CurrentStatus(): HasOne
{
    return $this->HasOne(OrderStatus::class)
     ->latestOfMany();
}

//Dynamic Relationships Using Subqueries

Subqueries allow us to select extra columns (attributes) right in our database query (the users query in our example).
 Let's look at how we can do this.

$users = User::query()
    ->addSelect(['last_login_at' => Login::select('created_at')
        ->whereColumn('user_id', 'users.id')
        ->latest()
        ->take(1)
    ])
    ->withCasts(['last_login_at' => 'datetime'])
    ->get();

@foreach ($users as $user)
    <tr>
        <td>{{ $user->name }}</td>
        <td>{{ $user->email }}</td>
        <td>
            @if ($user->last_login_at)
                {{ $user->last_login_at->format('M j, Y \a\t g:i a') }}
            @else
                Never
            @endif
        </td>
    </tr>
@endforeach
select
    "users".*,
    (
        select "created_at" from "logins"
        where "user_id" = "users"."id"
        order by "created_at" desc
        limit 1
    ) as "last_login_at"
from "users";


Using a subquery in this way allows us to get all the information we need for our users page in a single query. 
This technique provides huge performance wins, since we can keep both our database queries and memory usage to a minimum,
 plus we've avoided having to use caching.

 // Conditional aggregates
There's actually a really simple way to calculate these totals using a single database query. The trick is to put conditions within aggregate functions. Here's an example in SQL:

select
  count(*) as total,
  count(case when status = 'confirmed' then 1 end) as confirmed,
  count(case when status = 'unconfirmed' then 1 end) as unconfirmed,
  count(case when status = 'cancelled' then 1 end) as cancelled,
  count(case when status = 'bounced' then 1 end) as bounced
from subscribers

 total | confirmed | unconfirmed | cancelled | bounced
-------+-----------+-------------+-----------+---------
   200 |       150 |          50 |        30 |      25

Here's how you can write this query in Laravel using the query builder:

$totals = DB::table('subscribers')
    ->selectRaw('count(*) as total')
    ->selectRaw("count(case when status = 'confirmed' then 1 end) as confirmed")
    ->selectRaw("count(case when status = 'unconfirmed' then 1 end) as unconfirmed")
    ->selectRaw("count(case when status = 'cancelled' then 1 end) as cancelled")
    ->selectRaw("count(case when status = 'bounced' then 1 end) as bounced")
    ->first();

//What are circular relationships?
So what exactly are circular relationships? In a way, all relationships are circular. 
Consider a User and an Account. A user belongs to an account, and an account has many users. 
Another example is a Product and a Category. A product belongs to a category, and a category has many products. 
They are circular because they "point" to each other.

Here's how you might define this in Laravel:

class Product extends Model
{
    public function category()
    {
        return $this->belongsTo(Category::class);
    }
}

class Category extends Model
{
    public function products()
    {
        return $this->hasMany(Product::class);
    }
}
Now, typically you don't access both sides of a relationship in the same endpoint. 
For example, if you visit a product category page, you'll load all the products for that category. 
However, you likely won't load all the categories for those products, since you're already on the category page.

//Multi-Column Searching eloquent

Using where and orWhere
If you want to search across multiple columns with different conditions, you can chain where and orWhere:

php
Copy
$search = 'example';  // The term you are searching for

$results = Model::where('column1', 'like', "%$search%")
                ->orWhere('column2', 'like', "%$search%")
                ->orWhere('column3', 'like', "%$search%")
                ->get();
This query will search for the $search term in column1, column2, and column3.

2. Using where with orWhere inside a closure
If you have multiple conditions for different columns and need more control over grouping them, you can use a closure inside the where method:

php
Copy
$search = 'example';

$results = Model::where(function($query) use ($search) {
                    $query->where('column1', 'like', "%$search%")
                          ->orWhere('column2', 'like', "%$search%")
                          ->orWhere('column3', 'like', "%$search%");
                })
                ->get();
This ensures that all orWhere conditions are grouped together in one set of parentheses.

// Associative Array
An associative array uses named keys to store values.

<?php
// Creating an associative array
$person = array(
    "name" => "John",
    "age" => 30,
    "city" => "New York"
);

// Accessing elements by key
echo $person["name"]; // Output: John
echo $person["age"];  // Output: 30
echo $person["city"]; // Output: New York
?>

//Basic Lambda Function

In PHP, a lambda function (also called an anonymous function) is a function that does not have a name 
and can be created inline. You can use lambda functions in many scenarios like callbacks, filtering, 
or other functional programming tasks.

Here's an example of how to use lambda functions in PHP:

<?php
// Defining a simple lambda function
$square = function($x) {
    return $x * $x;
};

// Using the lambda function
echo $square(5); // Output: 25
?>


//Faster Options Than whereHas
$variant = Variant::first(); // Use this variant to search by name

// whereHas
Product::whereHas('variants', function ($query) use ($variant) {
            $query->where('name', $variant->name);
        })->get(); // 11.46ms
// join
Product::select('products.*')
    ->join('variants', function ($query) use ($variant){
        $query->on('variants.product_id', '=', 'products.id')
              ->where('variants.name', $variant->name);
    })->get(); // 1.89ms

So I would keep using whereHas for the readability if I'm working with a dataset where the results 
will fetch most of the rows on my target model or if the amount of records in the database is small enough that the impact of changing that query 
to a join would be minimal.

On the other hand, I would use a join if I'm working with a big database and the conditions would 
retrieve only a small subset of the records in my database.

//Use Unions to Run Queries Independently
Key Concepts:
union: Combines the results of multiple queries, excluding duplicate rows.
unionAll: Combines the results of multiple queries, including duplicate rows.
Example: Using union to Combine Queries Independently
Imagine you have two different tables or queries, and you want to combine their results.

Scenario: You have two queries—one to fetch users from the users table and another 
to fetch customers from the customers table. Both queries return similar data (e.g., name, email), 
and you want to combine these results into one collection.

<?php

use App\Models\User;
use App\Models\Customer;
use Illuminate\Support\Facades\DB;

// First query: Getting users
$query1 = User::select('name', 'email')
             ->where('status', 'active');

// Second query: Getting customers
$query2 = Customer::select('name', 'email')
                  ->where('status', 'active');

// Combine results using union
$combinedResults = $query1->union($query2)->get();

// Optionally, you can use `unionAll` to include duplicates:
$combinedResultsIncludingDuplicates = $query1->unionAll($query2)->get();

// Return or display the combined results
return $combinedResults;
?>

//Using Regular Expressions in Laravel Eloquent
Laravel Eloquent allows you to use the where clause with a REGEXP or LIKE for pattern matching in the database. Here's an example:

Example 1: Basic Fuzzy Search with REGEXP
You can use regular expressions for more flexible search patterns.

<?php

use App\Models\User;

$searchTerm = 'jo*n'; // Example search term with a wildcard
$users = User::where('name', 'REGEXP', $searchTerm)->get();

// Output the results
return $users;
?>
In this example, the REGEXP operator allows for searching for a pattern, where * or n can be replaced by any character. You could use this for more advanced searching techniques like:

Searching for variations in names (Jo*n matches John, Jon, etc.).
Finding words that start with certain letters (Jo.* matches John, Jonathan, etc.).
Example 2: Using LIKE for Basic Fuzzy Matching
For more basic "fuzzy" matching where you allow for some flexibility, LIKE is commonly used with wildcards (%).

<?php

use App\Models\User;

$searchTerm = 'jon'; // Example search term
$users = User::where('name', 'LIKE', "%{$searchTerm}%")->get();

// Output the results
return $users;
?>
Here, % represents any sequence of characters before or after the search term (jon), allowing matches like Johnny, Jonas, Jonathan, etc. This can simulate "fuzzy" searching by allowing variations of the search term.


//Run Authorization Policies in the Database
Laravel provides two primary ways of authorizing actions: gates and policies. 
Think of gates and policies like routes and controllers. Gates provide a simple, 
closure-based approach to authorization while policies, like controllers, group logic 
around a particular model or resource. In this documentation, we'll explore gates first and then examine policies.

You do not need to choose between exclusively using gates or exclusively using policies 
when building an application. Most applications will most likely contain some mixture of gates 
and policies, and that is perfectly fine! Gates are most applicable to actions that 
are not related to any model or resource, such as viewing an administrator dashboard. 
In contrast, policies should be used when you wish to authorize an action for a particular model or resource.


//Faster Ordering With Compound Indexes
In order to get these speeds, had to create a compound index on the logins table 
for the user_id and created_at columns.

Schema::table('logins', function (Blueprint $table) {
    $table->index(['user_id', 'created_at']);
});

//Ordering by has-one relationships

Consider an app which lists users with their name, email and company. It's currently ordering the users by their name, but what if we wanted to order them by their company instead?

Name	Email	Company
Adam Wathan	adam.wathan@gmail.com	NothingWorks Inc.
Chris Fidao	fideloper@gmail.com	Servers For Hackers
Jonathan Reinink	jonathan@reinink.ca	Code Distillery Inc.
Taylor Otwell	taylor@laravel.com	Laravel LLC.
This app includes a User model with a hasOne company relationship. Meaning, the company name exists in the companies table.

class User extends Model
{
    public function company()
    {
        return $this->hasOne(Company::class);
    }
}
There's actually two approaches we can use to order these users by their company. The first is using a join:

$users = User::select('users.*')
    ->join('companies', 'companies.user_id', '=', 'users.id')
    ->orderBy('companies.name')
    ->get();
Let's break this query down.

First we select only the columns from the users table, since, by default, Laravel will select all the columns when using a join, including the columns from the companies table.

User::select('users.*')
Next, we join in the companies table where the company's user_id equals the user's id.

->join('companies', 'companies.user_id', '=', 'users.id')
And finally, we order the records by the company's name column.

->orderBy('companies.name')
Here is the generated SQL for this query:

select users.*
from users
inner join companies on companies.user_id = users.id
order by companies.name asc

// Ordering by belongs-to relationships

Ordering by a belongs-to relationship is basically exactly the same as ordering by a has-one relationship, except the foreign keys are in opposite tables. To make this article useful from a documentation perspective, this section will be almost entirely duplicated from the has-one instructions. Feel free to skip down to the next section if you're reading this article in its entirety.

Consider an app which lists users with their name, email and company. It's currently ordering the users by their name, but what if we wanted to order them by their company instead?

Name	Email	Company
Adam Wathan	adam.wathan@gmail.com	NothingWorks Inc.
Chris Fidao	fideloper@gmail.com	Servers For Hackers
Jonathan Reinink	jonathan@reinink.ca	Code Distillery Inc.
Taylor Otwell	taylor@laravel.com	Laravel LLC.
This app includes a User model with a belongsTo company relationship. Meaning, the company name exists in the companies table.

class User extends Model
{
    public function company()
    {
        return $this->belongsTo(Company::class);
    }
}
Like the has-one relationships, there are two approaches we can use to order these users by their company. The first is using a join:

$users = User::select('users.*')
    ->join('companies', 'companies.id', '=', 'users.company_id')
    ->orderBy('companies.name')
    ->get();
Let's break this query down.

First we select only the columns from the users table, since, by default, Laravel will select all the columns when using a join, including the columns from the companies table.

User::select('users.*')
Next, we join in the companies table where the company's id equals the user's company_id.

->join('companies', 'companies.id', '=', 'users.company_id')
And finally, we order the records by the company's name column.

->orderBy('companies.name')
Here is the generated SQL for this query:

select users.*
from users
inner join companies on companies.id = users.company_id
order by companies.name asc

//Options for Ordering by a HasMany Relationship

Consider an app which lists users with their name, email and last login date. It's currently ordering the users by their name, but what if we wanted to order them by their last login date instead?

Name	Email	Last login
Adam Wathan	adam.wathan@gmail.com	3 months ago
Chris Fidao	fideloper@gmail.com	8 seconds ago
Jonathan Reinink	jonathan@reinink.ca	6 days ago
Taylor Otwell	taylor@laravel.com	A week ago
(As an aside, if you're wondering how to get the last login date in the most efficient way, be sure to see my dynamic relationships article.)

This app includes a User model with a hasMany logins relationship. Meaning, the login information exists in a logins table. Each time a user logs in, a new record is created in this table.

class User extends Model
{
    public function logins()
    {
        return $this->hasMany(Login::class);
    }
}
There's actually two approaches we can use to order by has-many relationships. This can be done with a join or with a subquery. Let's start with the subquery approach, since it's simpler.

As of Laravel 6, the orderBy() and orderByDesc() query builder methods support passing a query, instead of just a column name. When you do this, the query is executed as a subquery within the order by statement.

$users = User::orderByDesc(Login::select('created_at')
    ->whereColumn('logins.user_id', 'users.id')
    ->latest()
    ->take(1)
)->get();
Let's take a closer look at this subquery.

First we select the created_at column from the logins table.

Login::select('created_at')
Then we limit the results by comparing the login user_id column to the id of the user in the parent query.

->whereColumn('logins.user_id', 'users.id')
Then we call the latest() method, which orders the logins to get the most recent record first.

->latest()
And finally, we limit the results to only one row, since a subquery can only return a single row and column, but a user will (most likely) have more than one login record.

->take(1)
Here's the generated SQL for this query, which includes our login subquery in the order by statement.

select * from users order by (
    select created_at
    from logins
    where user_id = users.id
    order by created_at desc
    limit 1
) desc
Quite often I'll take this order by statement and create a model scope for it, just to nicely encapsulate it and make it easier to reuse. For example:

public function scopeOrderByLastLogin($query, $direction = 'desc')
{
    $query->orderBy(Login::select('created_at')
        ->whereColumn('logins.user_id', 'users.id')
        ->latest()
        ->take(1),
        $direction
    );
}
And now you can simply call this scope from your controllers (or wherever you need it):

$users = User::orderByLastLogin()->get();
Okay, now let's take a look at the join approach.

$users = User::select('users.*')
    ->join('logins', 'logins.user_id', '=', 'users.id')
    ->groupBy('users.id')
    ->orderByRaw('max(logins.created_at) desc')
    ->get();

//Options for Ordering by a BelongsToMany Relationship

Consider a library app which lists books with the title, author and last checkout user and date. It's currently ordering the books by the title, but what if we wanted to order them by the last checkout date or even the user name instead?

Book	Last Checkout
Clean Code: A Handbook of Agile Software Craftsmanship
Robert C. Martin
Matt Stauffer
6 years ago
Patterns of Enterprise Application Architecture
Martin Fowler
Freek Van der Herten
8 months ago
PHP and MySQL Web Development
Luke Welling
Jonathan Reinink
4 years ago
Test Driven Development: By Example
Kent Beck
Adam Wathan
19 years ago
The Pragmatic Programmer: From Journeyman to Master
Andy Hunt
Taylor Otwell
6 years ago
Working Effectively with Legacy Code
Michael C. Feathers
Caleb Porzio
1 day ago
This app includes a Book model with a belongsToMany users relationship that uses a checkouts pivot table. Each time a user checks out a book, a new record is created in this table, which includes the date in the borrowed_date column.

class Book extends Model
{
    public function user()
    {
        return $this->belongsToMany(User::class, 'checkouts')
            ->using(Checkout::class)
            ->withPivot('borrowed_date');
    }
}

class Checkout extends Pivot
{
    protected $table = 'checkouts';

    protected $casts = [
        'borrowed_date' => 'date',
    ];
}
Let's start with ordering by the last borrowed date.

This is actually the easier thing to order by. And that's because the borrowed_date exists on our checkouts pivot table. Checkouts are essentially a has-many relationship to books. One book "has many" checkouts. We just happen to be using the checkouts as the pivot table for the belongs-to-many relationship between books and users.

Meaning, if we want to sort by a column on the checkouts table, we can use the exact same techniques we covered above in the has-many relationships section.

Here's a quick review on how you can do this using a subquery:

$books = Books::orderByDesc(Checkout::select('borrowed_date')
    ->whereColumn('book_id', 'books.id')
    ->latest('borrowed_date')
    ->limit(1)
)->get();
You might be wondering, "what if I am not using a Checkout pivot model, can I still do this?"

Absolutely. The order by methods, as of Laravel 6, also allow you to provide a closure, where you can manually write the subquery.

$books = Books::orderByDesc(function ($query) {
    $query->select('borrowed_date')
        ->from('checkouts')
        ->whereColumn('book_id', 'books.id')
        ->latest('borrowed_date')
        ->limit(1);
})->get();
Here is the generated SQL for both of these queries (they are identical):

select * from books order by (
    select borrowed_date
    from checkouts
    where book_id = books.id
    order by borrowed_date desc
    limit 1
) desc
Okay, now let's move on to actually ordering by a belongs-to-many relationship column.

In our example, that means ordering by a column in the users table. Let's update the books query to order by the name of the user who last checked out that book.

Again, we'll use an order by subquery to do this:

$books = Book::orderBy(User::select('name')
    ->join('checkouts', 'checkouts.user_id', '=', 'users.id')
    ->whereColumn('checkouts.book_id', 'books.id')
    ->latest('checkouts.borrowed_date')
    ->take(1)
)->get();


//Ordering With NULLs Always Last
You might have a column like published_at in your database, and some rows might have NULL values for this column. By default, when you order the results, NULL values are treated as the lowest (in ascending order) or the highest (in descending order), but sometimes you want to ensure that NULL values always appear at the end.

Example: Sorting NULL Values Last with orderByRaw
Here’s how you can achieve that with Laravel Eloquent:

php
Copy
<?php

use App\Models\Post;

// Sorting posts by `published_at`, ensuring `NULL` values come last
$posts = Post::orderByRaw('published_at IS NULL, published_at DESC')->get();

// Output the results
return $posts;
?>

//Filtering and Sorting Anniversary Dates
Laravel Query Builder offers a more Eloquent solution:

$q->whereDate('created_at', '=', date('Y-m-d'));

Or, of course, instead of PHP date() you can use Carbon:

$q->whereDate('created_at', '=', Carbon::today()->toDateString());

//Make N+1 Issues Impossible
Eloquent can “eager load” relationships at the time you query the parent model. 
Eager loading alleviates the “N+1” query problem.

To eager load our user-post relationship we just need to modify Post::all() query 
and chain it with with() method.

...

Route::get('/', function () {
    $posts = Post::with('user')->get();   // get all posts and eager load the user relation

    return view('welcome', [
        'posts' => $posts,  // send it to 'welcome' view
    ]);
});

...
When we refresh the welcome page and check the “Queries” tab in the Debugbar again, 
we will see that we now only execute 2 statements. The first is to get all the post records 
and the second is to get the user data for the owners of the post records we retrieved. 
The total duration has also dropped to only 8.9ms.



// Full Text Searching With Rankings
PS: Using laravel built-in $table->fullText() is less accurate than using DB::statement(). So I would recommend also using this:

// instead of this
$table->fullText(['title', 'body']);

// do this
DB::statement('CREATE FULLTEXT INDEX posts_title_body_fulltext ON posts(title, body) WITH PARSER ngram');
ngram parser was added to MySQL on version 5.7.6 and has a better result than the default parser.

//Get the Distance Between Geographic Points eloquebt

Laravel Geographical Calculator helps you implement geographical calculation with several algorithms that help you deal with coordinates.

This package has two primary uses: getting the distance between a set of coordinates and getting the center between two or more coordinates.

First, here's an example of getting the distance between multiple sets of latitude and longitude points. The GeoFacade accepts various sets of points and calculates the distance between point one and point two, then points two and three, and so on.

use \KMLaravel\GeographicalCalculator\Facade\GeoFacade;
 
$distance = GeoFacade::setPoint([22, 37])
    ->setOptions(['units' => ['km']])
    // you can set unlimited lat/long points.
    ->setPoint([33, 40])
    // get the calculated distance between each point
    ->getDistance();
You can get the center between two sets of lat/long points using the getCenter() method. Like the getDistance() method, you can call setPoint() multiple times and it will calculate the center of multiple sets of points:

// Get the calculated center between these points.
$center = GeoFacade::setPoint([22, 37])
    // you can set unlimited points.
    ->setPoint([33, 40])
    ->getCenter();

//Designing Reliable Jobs
Laravel Queue offers advanced features to fine-tune your background processing:

Delayed Jobs
Delayed jobs allow scheduling tasks to be processed 
after a specified delay, useful for handling tasks that can be deferred 
without immediate processing.

dispatch(function () {     
  // Task logic 
})->delay(now()->addMinutes(10));

Rate Limiting
Laravel enables rate limiting to control the rate at which 
certain jobs are processed, preventing overwhelming external services or resources.

dispatch(
  new ProcessPodcast($podcast)
)->onQueue('podcasts')->throttle(5);


Job Events
Laravel provides events fired during the lifecycle of a queued job, 
enabling developers to hook into specific points for monitoring or logging purposes.

public function failed($exception) { 
    // Job failed logic
}

Retry Jobs
Failed jobs can be automatically retried a certain number of times, with delays between retries, enhancing fault tolerance.

public $tries = 3;  
public $retryAfter = 60; // seconds


Priority Queueing
Assigning different priority levels to queues ensures critical tasks are processed before less important ones, optimizing resource utilization.

dispatch(
  new SendEmail($details)
)->onQueue('high');

//Deployments of Laravel queue Production
you can use a Supervisor to manage this situation. Unlike Laravel-specific solutions, Supervisor operates at the operating system level. Essentially, it monitors the process and automatically restarts the queue worker if it stops unexpectedly.

To install Supervisor on your server, you can utilize two methods:

1. Utilize the terminal directly on the web server.
2. Employ SSH to access and install Supervisor.

sudo apt-get install supervisor
This will install the supervisor on your server.

Next, generate a file named laravel-worker.conf within the /etc/supervisor/conf.d directory. It’s best to stick to this convention when naming directories and files, but you can change them if needed.

Content to write in the file are:

[program:laravel-worker]
process_name=%(program_name)s_%(process_num)02d

command=php  //pathto your project//      /artisan queue:work

autostart=true
autorestart=true
stopasgroup=true
killasgroup=true

user=  // username according to you most probably root//

numprocs=1            
redirect_stderr=true
stdout_logfile=/home/forge/app.com/worker.log
stopwaitsecs=3600
stdout_logfile=/var/log/laravel-worker.log
The provided content should be written into the laravel-worker.conf file, save, and then execute the following commands:

sudo supervisorctl reread
 
sudo supervisorctl update
 
sudo supervisorctl start "laravel-worker:*"
Certainly.

Feel free to proceed. However, if you encounter any exceptions, because there are always exceptions. One such exception could be

“laravel-worker: ERROR (no such group).”

This will occur if your supervisor unable to detect your “laravel-worker.conf” file. To solve this problem add the below code to supervisord.conf file which is located in /etc directory most probably.

[include]
files = supervisor/conf.d/*.conf

//Scaling Your Job Processing in Laravel
Scaling your job processing setup ensures your system remains responsive under heavy workloads. Below are key strategies for scaling:

1. Add More Workers
Increase the number of worker processes (numprocs) to handle more jobs simultaneously. However, be mindful of resource consumption:

numprocs=20
Ensure the server has adequate resources (CPU, memory) to handle the extra load.

2. Prioritize Critical Jobs
You can create separate queues for different job priorities. This ensures that critical tasks are processed first:

[program:high-priority-worker]
command=php artisan queue:work --queue=high
numprocs=6

[program:low-priority-worker]
command=php artisan queue:work --queue=low
numprocs=7
3. Scale Horizontally
Distribute job processing across multiple servers to balance the load. Use a shared queue system like Redis to allow all servers to pull jobs from the same queue:

Set up multiple Supervisor instances on different servers.
Use a distributed queue (e.g., Redis) to synchronize jobs between servers.
4. Monitor and Adjust Configurations
Use tools like Laravel Horizon to monitor your queue workers' performance in real-time. Horizon provides visual insights into job processing, queue lengths, and resource consumption, allowing you to fine-tune configurations as needed.

//Configuration Reference

In Laravel, queue workers allow you to process jobs in the background, and there are a variety of configurations that you can adjust for better control over how jobs are handled. These configurations are typically done in two places:

Queue Worker Configuration (e.g., supervisor settings).
Job Configuration (e.g., retries, timeouts).
Let's break it down for both queue worker configurations and job configuration:

1. Queue Worker Configuration (via Supervisor)
If you want to manage and configure Laravel workers (which process jobs), you can configure them using Supervisor. Supervisor is commonly used in production to ensure workers are running, are restarted if they fail, and can be managed easily.

Here’s an example configuration for Supervisor:

Example: Supervisor Configuration for Laravel Workers
Create a config file for your workers in /etc/supervisor/conf.d/laravel-worker.conf:

[program:laravel-worker]
process_name=%(program_name)s_%(process_num)02d
command=php /path/to/your/project/artisan queue:work --sleep=3 --tries=3 --queue=default
autostart=true
autorestart=true
user=youruser
numprocs=8  # Number of processes to spawn (adjust based on your server capacity)
redirect_stderr=true
stdout_logfile=/path/to/your/project/storage/logs/worker.log
stopwaitsecs=3600

Key Configuration Options for Queue Worker:
command: This is the command to run for processing jobs, such as php artisan queue:work.

--sleep: Defines how long the worker should sleep before checking for more jobs (in seconds).
--tries: Defines how many times a job should be retried before failing.
--queue: Specifies the queue(s) the worker should listen to (e.g., default or emails).
numprocs: Number of worker processes to run (you can scale this depending on your server’s resources).

autostart: Ensures the worker is started automatically when Supervisor starts.

autorestart: Ensures the worker is restarted if it crashes.

stdout_logfile: Path to the log file where worker output will be saved.

stopwaitsecs: The number of seconds to wait for a worker to stop gracefully.

After you’ve added the configuration, run these commands to apply the changes:

sudo supervisorctl reread
sudo supervisorctl update
sudo supervisorctl start "laravel-worker:*"

2. Job Configuration (via Laravel Queue Configuration)
Laravel provides several options for configuring the behavior of jobs themselves. You can configure these behaviors in the job class or in the queue configuration.

Job Class Configuration:
You can define specific behaviors for each job using the Job class. Here are some important properties and methods you might use:

Example: Job Configuration in Laravel

<?php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Support\Facades\Log;

class ExampleJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    // Specify the number of attempts before failing
    public $tries = 3;

    // Specify the timeout for the job
    public $timeout = 120;

    // Specify the job's unique identifier (if needed for uniqueness)
    public $uniqueFor = 3600; // The job will be unique for 1 hour

    public function handle()
    {
        // Job processing logic
        Log::info("Processing job...");
    }

    // Configure the job's failure behavior
    public function failed(\Exception $exception)
    {
        // Handle the job failure, such as logging the failure or notifying someone
        Log::error("Job failed: " . $exception->getMessage());
    }
}

Important Properties for Job Configuration:
$tries: Defines how many times the job should be attempted before it is marked as failed.
$timeout: Defines how many seconds the job should run before being marked as a timeout.
$uniqueFor: Prevents the job from being dispatched again if it was previously dispatched within the specified time (in seconds).
failed(): This method allows you to define what happens when the job fails, e.g., sending a notification, logging the error, etc.
3. Queue Configuration in config/queue.php
You can also configure how your queues behave globally in the config/queue.php file. This is where you configure things like default queue connection, retry time, and queue-specific settings.

Example: config/queue.php Configuration

return [
    'default' => env('QUEUE_CONNECTION', 'sync'),

    'connections' => [
        'sync' => [
            'driver' => 'sync',
        ],

        'database' => [
            'driver' => 'database',
            'table' => 'jobs',
            'queue' => 'default',
            'retry_after' => 90, // seconds before a job is retried
            'after_commit' => false,
        ],

        'redis' => [
            'driver' => 'redis',
            'connection' => 'default',
            'queue' => 'default',
            'retry_after' => 90,
            'block_for' => null,
        ],
    ],
];


Key Queue Configuration Options:
default: The default queue connection that Laravel should use. This can be set to sync, database, redis, etc.
retry_after: Defines the number of seconds before a job is retried.
after_commit: If set to true, jobs will be pushed to the queue only after the database transaction commits.

//Revoking Authentication Tokens

You may "revoke" tokens by deleting them from your database 
using the tokens relationship that is provided by the Laravel\Sanctum\HasApiTokens trait:

// Revoke all tokens...
$user->tokens()->delete();
 
// Revoke the token that was used to authenticate the current request...
$request->user()->currentAccessToken()->delete();
 
// Revoke a specific token...
$user->tokens()->where('id', $tokenId)->delete();

//Designing Response Payloads

As you have already read, resources may be 
returned directly from routes and controllers:

use App\Http\Resources\UserResource;
use App\Models\User;
 
Route::get('/user/{id}', function (string $id) {
    return new UserResource(User::findOrFail($id));
});

However, sometimes you may need to customize the outgoing HTTP response 
before it is sent to the client. There are two ways to accomplish this. First, 
you may chain the response method onto the resource. This method 
will return an Illuminate\Http\JsonResponse instance, giving you full control over the response's headers:

use App\Http\Resources\UserResource;
use App\Models\User;
 
Route::get('/user', function () {
    return (new UserResource(User::find(1)))
        ->response()
        ->header('X-Value', 'True');
});


//Conditionally Omitting and Including Data
When building APIs with Laravel, you often need to include multiple attributes based on a single condition. 
Laravel’s API Resources provide a powerful mergeWhen method to achieve this efficiently. 
Let's explore how to use this feature to create cleaner, more conditional API responses.

Understanding mergeWhen
The mergeWhen method allows you to include multiple attributes 
In your resource response based on a single condition. 
This is particularly useful when you have several related attributes that should be included or excluded together.

Basic Usage
Here’s a simple example of how to use mergeWhen:

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class UserResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'name' => $this->name,
            'email' => $this->email,
            $this->mergeWhen($request->user()->isAdmin(), [
                'last_login' => $this->last_login,
                'ip_address' => $this->ip_address,
                'is_banned' => $this->is_banned,
            ]),
        ];
    }
}
In this example, the additional user information is only included if the authenticated user is an admin.

//Adding optional Parameter in routes
How to Use Optional Parameters in Laravel Routes

Adding optional parameters in Laravel routes is easy. You just need to add a ? to the parameter name in the route and provide a default value in the logic.

Example: Showing a Product

Let’s create a route to show a product. If no ID is provided in the URL, it defaults to “default”.

Route::get('/product/{id?}', function ($id = 'default') {
    return "Product ID: $id";
});
Visiting /product will return Product ID: default.
Visiting /product/123 will return Product ID: 123.
Adding Rules to Optional Parameters

You can add constraints to the optional parameters using the where method. For example, only allowing numbers for the id:

Route::get('/product/{id?}', function ($id = 'default') {
    return "Product ID: $id";
})->where('id', '[0-9]+');
/product/123 works fine.
/product/abc will return a 404 error